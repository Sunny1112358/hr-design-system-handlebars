(window["webpackJsonpardplayer"] = window["webpackJsonpardplayer"] || []).push([["vendors~pluginchromecast~plugindash~pluginhls~pluginhtmla~pluginhtmlv"],{

/***/ "./app/controller/AbstractPlayerCtrl.ts":
/*!**********************************************!*\
  !*** ./app/controller/AbstractPlayerCtrl.ts ***!
  \**********************************************/
/*! exports provided: AbstractPlayerCtrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractPlayerCtrl\", function() { return AbstractPlayerCtrl; });\n/* harmony import */ var _player_Player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../player/Player */ \"./app/player/Player.ts\");\n/* harmony import */ var _model_Environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Environment */ \"./app/model/Environment.ts\");\n/* harmony import */ var _utils_Storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Storage */ \"./app/utils/Storage.ts\");\n/* harmony import */ var _PlayerPixelController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PlayerPixelController */ \"./app/controller/PlayerPixelController.ts\");\n/* harmony import */ var _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/PlayerModel */ \"./app/model/PlayerModel.ts\");\n/* harmony import */ var _ErrorController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ErrorController */ \"./app/controller/ErrorController.ts\");\n/* harmony import */ var emap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! emap */ \"../emap/js/emap.js\");\n/* harmony import */ var emap__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(emap__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../index */ \"./app/index.ts\");\n/* harmony import */ var _utils_Decorators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/Decorators */ \"./app/utils/Decorators.ts\");\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar _AbstractPlayerCtrl_lastSubclipSeektrigger, _AbstractPlayerCtrl_lastPlayheadUpdateTime, _AbstractPlayerCtrl_buffering, _AbstractPlayerCtrl_percentBuffered, _AbstractPlayerCtrl__dvrDriftBase, _AbstractPlayerCtrl__dvrDriftAnchorTime, _AbstractPlayerCtrl__cumulativeDrift, _AbstractPlayerCtrl__dropTimeUpdates, _AbstractPlayerCtrl_seekPrevPos, _AbstractPlayerCtrl_seekToPos, _AbstractPlayerCtrl_updateTickerTimeout, _AbstractPlayerCtrl_errorState;\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Abstrakte Player-Controller Basisklasse. Wird vom jeweiligen Plugin erweitert.\r\n * @abstract\r\n **/\n\nvar AbstractPlayerCtrl = class AbstractPlayerCtrl {\n  /**\r\n   * @constructor\r\n   * @param {Player} player\r\n   * @param {HTMLVideoElement|HTMLAudioElement} mediaElement\r\n   */\n  constructor(player, mediaElement) {\n    this.dvrUtil = null;\n    /** minimum live offset in seconds that will _not_ be displayed as live */\n\n    this.minDisplayedLiveOffset = 7;\n    this.subtitleListeners = [];\n    this.audioTrackListeners = [];\n    this.audioTracks = [];\n    this.audioTrack = null; // state vars\n\n    _AbstractPlayerCtrl_lastSubclipSeektrigger.set(this, 0);\n\n    _AbstractPlayerCtrl_lastPlayheadUpdateTime.set(this, 0);\n\n    _AbstractPlayerCtrl_buffering.set(this, false);\n\n    _AbstractPlayerCtrl_percentBuffered.set(this, 0);\n\n    this._duration = 0;\n    this._dvrModeEnabled = false;\n    /** DVR Zeitstempel-driftkorrektur - bekannter unix-zeitwert zu #_dvrDriftAnchorTime */\n\n    _AbstractPlayerCtrl__dvrDriftBase.set(this, 0\n    /** DVR Zeitstempel-driftkorrektur - bekannter Zeitpunkt im stream aus dem #_dvrDriftBase berechnet wurde */\n    );\n    /** DVR Zeitstempel-driftkorrektur - bekannter Zeitpunkt im stream aus dem #_dvrDriftBase berechnet wurde */\n\n\n    _AbstractPlayerCtrl__dvrDriftAnchorTime.set(this, 0\n    /** DVR Zeitstempel-driftkorrektur - summierte zeitfehler vorheriger Pausenzeiten */\n    );\n    /** DVR Zeitstempel-driftkorrektur - summierte zeitfehler vorheriger Pausenzeiten */\n\n\n    _AbstractPlayerCtrl__cumulativeDrift.set(this, 0);\n\n    this.isAtEnd = false;\n    /** Sonderbehandlung von Android-Devices */\n\n    this._useAndroidInitialSeekFallback = false;\n    this.__seeking = false;\n\n    _AbstractPlayerCtrl__dropTimeUpdates.set(this, 0);\n\n    _AbstractPlayerCtrl_seekPrevPos.set(this, 0);\n\n    _AbstractPlayerCtrl_seekToPos.set(this, 0);\n\n    this._ready = false;\n    this._pendingSeek = 0;\n\n    _AbstractPlayerCtrl_updateTickerTimeout.set(this, -1);\n\n    _AbstractPlayerCtrl_errorState.set(this, false);\n\n    this._dvrEnabled = false;\n    this._dvrIsLive = false;\n    this._dvrWindow = 0;\n    this.pinnedDvrSync = null; // ref variables\n\n    this.player = player;\n    this.mediaElement = mediaElement; // notify plugins & addons\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_INIT, {});\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STATUS_CHANGE, {\n      status: 'init'\n    }); // add player listeners\n\n    this.emap = new emap__WEBPACK_IMPORTED_MODULE_6___default.a();\n    this.addEventListeners();\n    _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].for(this.player).storageListeners.add(this); // event management for subtitle tracks\n\n    if (mediaElement instanceof HTMLMediaElement) {\n      mediaElement.textTracks.onaddtrack = e => {\n        this.onTextTracksChanged(e);\n      };\n\n      mediaElement.textTracks.onremovetrack = e => {\n        this.onTextTracksChanged(e);\n      };\n    } // notify plugins & addons\n\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STATUS_CHANGE, {\n      status: 'ready'\n    });\n  }\n  /** Player-Model */\n\n\n  get model() {\n    return this.player.model;\n  }\n\n  get pc() {\n    return this.model.playerConfig;\n  }\n\n  get mc() {\n    return this.model.mediaCollection;\n  }\n\n  get vc() {\n    return this.player.viewCtrl;\n  }\n\n  get g() {\n    return _model_Environment__WEBPACK_IMPORTED_MODULE_1__[\"Environment\"].instance;\n  }\n\n  get __cumulativeDrift() {\n    return __classPrivateFieldGet(this, _AbstractPlayerCtrl__cumulativeDrift, \"f\");\n  }\n\n  debugString() {\n    return 'none';\n  }\n\n  debugQualityLevel() {\n    return [-1, 1];\n  }\n  /**\r\n   * list of all sub-qualities available for selection as a tuple of index and name, including -1 for auto\r\n   */\n\n\n  get subQualities() {\n    _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].error('using base implementation for subQuality listing!');\n    return [{\n      level: -1,\n      label: 'Auto',\n      width: -1\n    }];\n  }\n  /**\r\n   * select the given sub-quality level for playback\r\n   * if the level -1 or out of bounds, default to \"auto\" mode\r\n   * @param level\r\n   */\n\n\n  selectSubQuality(level) {\n    _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].error('using base implementation for subQuality selection!');\n  }\n  /**\r\n   * the sub-quality currently selected for playback\r\n   * -1 if none are available or \"auto\" is selected\r\n   */\n\n\n  get currentSubQuality() {\n    _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].error('using base implementation for currentSubQuality!');\n    return -1;\n  }\n  /**\r\n   * Gibt eine Logausgabe aus\r\n   */\n\n\n  log() {\n    for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {\n      input[_key] = arguments[_key];\n    }\n\n    _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].log(\"[\" + this.getClassTypeString() + \"]\", ...input);\n  }\n  /**\r\n   * interner eventhandler der alle registrierten untertitel-handler über veränderungen benachrichtigt\r\n   * @param e\r\n   */\n\n\n  onTextTracksChanged(e) {\n    this.subtitleListeners.forEach(listener => {\n      listener.onTextTracksChanged(e);\n    });\n  }\n  /**\r\n   * registriert einen eventhandler für veränderungen am untertitel-stream\r\n   */\n\n\n  addSubtitleListener(callee) {\n    if (!this.subtitleListeners.includes(callee)) {\n      this.subtitleListeners.push(callee);\n    }\n  }\n  /**\r\n   * entfernt einen zuvor registrierten eventhandler für untertitelveränderungen\r\n   */\n\n\n  removeSubtitleListener(callee) {\n    var i = this.subtitleListeners.indexOf(callee);\n\n    if (i !== -1) {\n      this.subtitleListeners = this.subtitleListeners.splice(i, 1);\n    }\n  }\n  /**\r\n   * interner eventhandler der alle registrierten audio-track-handler über veränderungen benachrichtigt\r\n   */\n\n\n  onAudioTracksChanged() {\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].AUDIO_TRACK_LIST_CHANGED, {\n      audioTracks: this.audioTracks\n    });\n    this.audioTrackListeners.forEach(listener => {\n      listener.onAudioTracksChanged(this.audioTracks);\n    });\n  }\n  /**\r\n   * registriert einen eventhandler für veränderungen am audio-stream\r\n   */\n\n\n  addAudioTrackListener(callee) {\n    if (!this.audioTrackListeners.includes(callee)) {\n      this.audioTrackListeners.push(callee);\n    }\n  }\n  /**\r\n   * entfernt einen zuvor registrierten eventhandler für audio-stream-verfügbarkeit\r\n   */\n\n\n  removeAudioTrackListener(callee) {\n    var i = this.audioTrackListeners.indexOf(callee);\n\n    if (i !== -1) {\n      this.audioTrackListeners = this.audioTrackListeners.splice(i, 1);\n    }\n  }\n  /**\r\n   * Methode wird von den Klassen aufgerufen, die diese Klasse erben.\r\n   * Definiert ein StandardVerhalten und so wird doppelter Code vermieden.\r\n   * Diese Methode fügt die Methoden an die Elemente innerhalb des ViewControllers.\r\n   * @method addEventListeners\r\n   * @public\r\n   */\n\n\n  addEventListeners() {\n    this.emap.map(this.mediaElement, 'loadstart', this.onLoadStart, this);\n    this.emap.map(this.mediaElement, 'canplay', this.onCanPlay, this);\n    this.emap.map(this.mediaElement, 'play', this.onPlay, this);\n    this.emap.map(this.mediaElement, 'pause', this.onPause, this);\n    this.emap.map(this.mediaElement, 'error', this.onError, this);\n    this.emap.map(this.mediaElement, 'waiting', this.onWaiting, this);\n    this.emap.map(this.mediaElement, 'ended', this.onEnded, this);\n    this.emap.map(this.mediaElement, 'timeupdate', this.onTimeUpdate, this);\n    this.emap.map(this.mediaElement, 'seeking', this.onSeeking, this);\n    this.emap.map(this.mediaElement, 'seeked', this.onSeekEnd, this);\n    this.emap.map(this.mediaElement, 'loadedmetadata', this.onLoadedMetadata, this);\n    this.emap.map(this.mediaElement, 'loadeddata', this.onLoadedData, this);\n    this.emap.map(this.mediaElement, 'durationchange', this.onDurationChange, this);\n    this.emap.map(this.mediaElement, 'progress', this.onProgress, this);\n    this.emap.map(this.mediaElement, 'stalled', this.onStalled, this);\n  }\n  /**\r\n   * PLAYER EVENTS\r\n   */\n\n\n  onLoadStart() {\n    var _a, _b;\n\n    if (_model_Environment__WEBPACK_IMPORTED_MODULE_1__[\"Environment\"].instance.isAndroidDevice && ((_b = (_a = this.mediaElement) === null || _a === void 0 ? void 0 : _a.currentSrc) !== null && _b !== void 0 ? _b : '').toLowerCase().indexOf('.m3u8') > 0) {\n      this._useAndroidInitialSeekFallback = true;\n    }\n  }\n  /**\r\n   * Eventhandler - canPlay-Event\r\n   */\n\n\n  onCanPlay() {\n    if (!(this.mediaElement instanceof HTMLMediaElement) || this.mediaElement.readyState >= this.mediaElement.HAVE_FUTURE_DATA) {\n      this.bufferingEventHandler(false);\n    }\n  }\n  /**\r\n   * Eventhandler - Play-Event\r\n   */\n\n\n  onPlay() {\n    this.startTicker();\n    this.playEventHandler();\n    this.bufferingEventHandler(false);\n  }\n  /**\r\n   * Eventhandler - Pause-Event\r\n   * @param event\r\n   */\n\n\n  onPause(event) {\n    this.pauseEventHandler(event, this.mediaElement.currentTime >= this.mediaElement.duration);\n  }\n  /**\r\n   * Eventhandler - Fehler-Event\r\n   */\n\n\n  onError(event) {\n    this.handleError(event);\n  }\n  /**\r\n   * Eventhandler - Waiting Event\r\n   * @param event\r\n   */\n\n\n  onWaiting(event) {\n    if (this.mediaElement instanceof HTMLMediaElement) {\n      this.bufferingEventHandler(this.mediaElement.readyState < this.mediaElement.HAVE_FUTURE_DATA);\n    }\n  }\n  /**\r\n   * Eventhandler - Ended Event\r\n   * @param event\r\n   */\n\n\n  onEnded(event) {\n    this.stopTicker();\n    this.mediaElement.pause();\n    this.endEventHandler(event); // Not all browsers will trigger a timeupdate on rewind so we do it here. #9347\n\n    this.onTimeChange(this._duration, 0);\n  }\n  /**\r\n   * Eventhandler - Zeitupdate Events\r\n   */\n\n\n  onTimeUpdate(event) {\n    this.onProgress(null);\n  }\n  /**\r\n   * Eventhandler - Seeking Event\r\n   */\n\n\n  onSeeking() {\n    // 7089 - drop followup time updates\n    this.__seeking = true;\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_SEEK_START, {\n      from: __classPrivateFieldGet(this, _AbstractPlayerCtrl_seekPrevPos, \"f\"),\n      to: __classPrivateFieldGet(this, _AbstractPlayerCtrl_seekToPos, \"f\")\n    });\n    this.bufferingEventHandler(true);\n  }\n  /**\r\n   * Eventhandler - Seek-End Event\r\n   */\n\n\n  onSeekEnd(event) {\n    // 7089 - drop followup time updates\n    this.__seeking = false;\n\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl__dropTimeUpdates, 1, \"f\");\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_SEEK_END, {\n      position: this.getCurrentTime()\n    });\n    this.bufferingEventHandler(false);\n  }\n  /**\r\n   * @return {boolean}\r\n   */\n\n\n  isSeeking() {\n    return this.__seeking;\n  }\n  /**\r\n   * Eventhandler - Metadata Loaded Event\r\n   */\n\n\n  onLoadedMetadata() {\n    this._ready = true;\n    this.evalInitialSeek();\n  }\n  /**\r\n   * Eventhandler - Loaded Data Event\r\n   */\n\n\n  onLoadedData() {\n    this.evalInitialSeek();\n  }\n  /**\r\n   * Eventhandler - Duration-Event\r\n   */\n\n\n  onDurationChange(event) {\n    this._duration = this.mediaElement.duration;\n    this._ready = true;\n    this.onProgress(null);\n  }\n  /**\r\n   * Eventhandler - Progress-Event\r\n   * @param event\r\n   */\n\n\n  onProgress(event) {\n    var _a;\n\n    if (!this.mediaElement || (event === null || event === void 0 ? void 0 : event.type) === 'waiting' && (__classPrivateFieldGet(this, _AbstractPlayerCtrl__dropTimeUpdates, \"f\") > 0 || this.__seeking)) {\n      return;\n    }\n\n    var position = this.getCurrentTime();\n    var duration = this.getDuration();\n    var currEnd = -1;\n    var ranges = (_a = this.mediaElement) === null || _a === void 0 ? void 0 : _a.buffered;\n\n    if (ranges) {\n      for (var i = 0; i < ranges.length; i++) {\n        if (ranges.start(i) <= position && ranges.end(i) >= position) {\n          currEnd = ranges.end(i);\n        }\n      }\n    } // Noch nicht ausreichend Daten im Speicher, um eine Range zu ermitteln.\n\n\n    if (currEnd === -1) {\n      return;\n    }\n\n    var percentLoaded = Math.round(currEnd / duration * 100);\n    this.bufferProgressHandler(percentLoaded);\n  }\n  /**\r\n   * Eventhandler - Stalled Event\r\n   * @param event\r\n   */\n\n\n  onStalled(event) {\n    this.onProgress(event);\n  }\n  /**\r\n   * Eventhandler - Source-Error Event\r\n   */\n\n\n  onSourceError(e) {\n    this.stopTicker();\n    this.handleError(e);\n  }\n  /**\r\n   * LOGIC HANDLERS\r\n   */\n\n  /**\r\n   * Update-Methode - Zeitänderung\r\n   */\n\n\n  onTimeChange(duration, time) {\n    this.updateDuration(duration);\n    this.updateTime(Math.max(time, 0));\n  }\n  /**\r\n   * Ereignishandler der bei Änderungen des Buffering-Flags aufgerufen wird.\r\n   * @param {boolean} isBuffering - Status, ob Buffering aktiv ist.\r\n   */\n\n\n  bufferingEventHandler(isBuffering) {\n    this.onProgress(null); // console.log('bufferingHandler', event, isBuffering, new Error().stack)\n\n    if (isBuffering && !this.isAtEnd) {\n      this.vc.showBufferingIndicator();\n    } else {\n      this.vc.hideBufferingIndicator();\n    } // notify plugins\n\n\n    if (isBuffering !== __classPrivateFieldGet(this, _AbstractPlayerCtrl_buffering, \"f\")) {\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl_buffering, isBuffering, \"f\");\n\n      this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_BUFFERING, {\n        isBuffering: isBuffering\n      });\n    }\n  }\n  /**\r\n   * handler der bei buffer-updates während der Wiedergabe aufgerufen wird\r\n   * @param {number} percentLoaded - Wiedergabefortschritt in Sekunden\r\n   */\n\n\n  bufferProgressHandler(percentLoaded) {\n    this.vc.updateBufferProgress(percentLoaded);\n\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl_percentBuffered, percentLoaded, \"f\");\n  }\n  /**\r\n   * Führt im Anschluss das Event und Verhalten aus, das hinzugefügt wurde.\r\n   */\n\n\n  playEventHandler() {\n    this.stopOtherPlayingPlayers();\n    this.model.playstate = _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__[\"PlayerModel\"].PLAYSTATE_PLAYING;\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STATUS_CHANGE, {\n      status: 'play'\n    });\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n\n    this.isAtEnd = false; // Notify plugins\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_PLAY_STREAM, {}); // Replay Event wird geworfen wenn ein Clip bis zum Ende geschaut wurde.\n\n    if (this.player.pixelController._isReplay) {\n      this.player.pixelController.triggerPixel(_PlayerPixelController__WEBPACK_IMPORTED_MODULE_3__[\"PlayerPixelController\"].SUPER_REPLAY);\n      this.player.pixelController._isReplay = false;\n    } // Trigger Pixel\n\n\n    this.player.pixelController.initialPlayTrigger();\n  }\n  /**\r\n   * Diese Methode wird getriggerd, wenn ein Stream pausiert werden soll\r\n   * @param {Event} event - Event, das hinzugefügt wurde.\r\n   * @param {boolean} ended - wird dem pause-event mitgereicht um anzuzeigen dass dieses pause-event teil des beendens des streams ist\r\n   */\n\n\n  pauseEventHandler(event, ended) {\n    if (ended === void 0) {\n      ended = false;\n    }\n\n    this.model.playstate = _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__[\"PlayerModel\"].PLAYSTATE_PAUSED; // FIXME\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STATUS_CHANGE, {\n      status: 'pause'\n    }); // Notify plugins\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_PAUSE_STREAM, {\n      ended\n    });\n  }\n  /**\r\n   * Diese Methode wird getriggerd, wenn ein Stream gestoppt werden soll\r\n   * @param {Event} event  - Event, das hinzugefügt wurde.\r\n   */\n\n\n  stopEventHandler(event) {\n    if (this.isAtEnd) {\n      return;\n    } // Abspielzustand hinterlegen\n\n\n    this.model.playstate = _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__[\"PlayerModel\"].PLAYSTATE_STOPPED;\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STATUS_CHANGE, {\n      status: 'stop'\n    });\n    this.bufferingEventHandler(false); // make sure we are showing the current state, then _stop updating_\n\n    this.updateTicker();\n    this.stopTicker(); // Notify plugins\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STOP_STREAM, {});\n  }\n  /**\r\n   * Ereignishandler der bei Streamende aufgerufen wird.\r\n   * @param {Event} event\r\n   */\n\n\n  endEventHandler(event) {\n    this.jumpToStart();\n    this.player.pixelController.triggerPixel(_PlayerPixelController__WEBPACK_IMPORTED_MODULE_3__[\"PlayerPixelController\"].CLIP_ENDED);\n    this.pauseEventHandler(event, true);\n    this.vc.hidePosterFrame(); // Bei VOD / AOD zeigen wir den erneut Abspielen Button\n\n    if (!this.mc.isLive) {\n      this.vc.showPlayAgain();\n    }\n\n    this.vc.hideBufferingIndicator();\n    this.vc.exitFullscreen(); // setzt das Flag _isReplay im pixelController auf true\n\n    if (this.player.pixelController) {\n      this.player.pixelController._isReplay = true;\n    }\n\n    this.isAtEnd = true; // Notify plugins\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_END_STREAM, {});\n  }\n  /**\r\n   * API CALLS\r\n   */\n\n  /**\r\n   * Initiales Seeking auswerten.\r\n   */\n\n\n  evalInitialSeek() {\n    if (this._pendingSeek > 0) {\n      if (this.canSeek()) {\n        var targetSeekTime = this._pendingSeek;\n        this._pendingSeek = 0;\n        this.setCurrentTime(targetSeekTime, false, false, true);\n      }\n    } else {\n      this.play();\n    }\n  }\n  /**\r\n   * Setzt die Cliplänge im Model.\r\n   * @param {number} seconds\r\n   */\n\n\n  updateDuration(seconds) {\n    if (this.model.duration !== seconds) {\n      this.model.duration = seconds; // Notify plugins\n\n      this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_UPDATE_STREAM_DURATION, {\n        duration: seconds\n      });\n    }\n  }\n  /**\r\n   * Restarts the clip.\r\n   */\n\n\n  restartMedia() {\n    this.jumpToStart();\n    this.play();\n  }\n  /**\r\n   * Reset any start or endtime sets.\r\n   */\n\n\n  resetStartAndEndTime() {\n    this.pc.generic.vodStartSeconds = 0;\n    this.pc.generic.vodEndSeconds = 0;\n  }\n  /**\r\n   * Sets the time in the model\r\n   * @param {number} seconds\r\n   */\n\n\n  updateTime(seconds) {\n    this.model.time = seconds;\n    this.vc.updateTime(seconds);\n    this.vc.updateTimeline(seconds, this.model.duration);\n    var now = Date.now();\n\n    if (now >= __classPrivateFieldGet(this, _AbstractPlayerCtrl_lastPlayheadUpdateTime, \"f\") + 1000) {\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl_lastPlayheadUpdateTime, now, \"f\"); // Calculate dvr timings\n\n\n      var dvrRelativeTime = 0;\n      var duration = Math.round(this.model.duration);\n      var pixelSeconds = Math.round(seconds);\n\n      if (this.vc._dvrEnabledAndRequested && !this.vc._dvrIsLive) {\n        dvrRelativeTime = Math.min(Math.round(duration - seconds), duration);\n      }\n\n      this.player.pixelController.triggerCustomPixel(_PlayerPixelController__WEBPACK_IMPORTED_MODULE_3__[\"PlayerPixelController\"].SUPER_PLAYHEAD_POSITION, false, {\n        currentTime: pixelSeconds,\n        duration: duration,\n        dvrRelativeTime: -dvrRelativeTime\n      });\n    } // Subclipping\n\n\n    var startTime = this.pc.generic.vodStartSeconds;\n    var endTime = this.pc.generic.vodEndSeconds;\n\n    if (startTime > 0 && seconds < startTime) {\n      // Vermeiden, dass unscharfe Suchen zu einem Loop führen\n      var thisInterpolatedTrigger = Math.round(seconds);\n\n      if (Math.abs(__classPrivateFieldGet(this, _AbstractPlayerCtrl_lastSubclipSeektrigger, \"f\") - thisInterpolatedTrigger) > 3) {\n        // unschärfe\n        this.setCurrentTime(startTime, false, false, true);\n\n        __classPrivateFieldSet(this, _AbstractPlayerCtrl_lastSubclipSeektrigger, thisInterpolatedTrigger, \"f\");\n      }\n    } else {\n      if (endTime > 0 && seconds > endTime) {\n        this.setCurrentTime(startTime, false, false, true);\n        this.pause();\n      }\n    } // Notify plugins\n\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_UPDATE_STREAM_TIME, {\n      currentTime: seconds\n    }); // ARDONI7-15679 - stop other players in iframes\n\n    if (window.parent !== window && _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].AVAILABLE && this.model.playstate === _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__[\"PlayerModel\"].PLAYSTATE_PLAYING) {\n      if (_utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].get(_utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].SUFFIX_GLOBAL, _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].CURRENT_PLAYERID, true) !== this.player.getId()) {\n        this.pause();\n      }\n    }\n  }\n  /**\r\n   * Diese Methode entfernt gebundene Eventlistener\r\n   */\n\n\n  removeEventListeners() {\n    this.emap.all();\n  }\n  /**\r\n   * Entfernt diverse Elemente um sie für den Garbagecollector zum Löschen freizugeben.\r\n   */\n\n\n  dispose() {\n    this.log('dispose()');\n    this.removeEventListeners();\n    _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].for(this.player).storageListeners.delete(this); // dispose of event handler references\n\n    if (this.mediaElement instanceof HTMLMediaElement) {\n      this.mediaElement.textTracks.onaddtrack = null;\n      this.mediaElement.textTracks.onremovetrack = null;\n    } // pause the player element to make sure no overlapping playback occurs when it is\n    // neither re-used nor the player removed (e.g. switching chromecast)\n\n\n    this.mediaElement.pause();\n    this.subtitleListeners = [];\n    this.audioTrackListeners = [];\n    this.stopTicker();\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_STOP_STREAM, {}); // these _might_ contain further references from specialized controllers\n\n    this.audioTracks = [];\n    this.audioTrack = null;\n  }\n  /**\r\n   * Stoppt ggf. weitere, spielende Player.\r\n   */\n\n\n  stopOtherPlayingPlayers() {\n    // keep track of current playing player, notifying others to stop\n    _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].add(_utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].SUFFIX_GLOBAL, _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].CURRENT_PLAYERID, this.player.getId(), true, true);\n  }\n\n  onStorageValueChanged(key, value) {\n    if (key === _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].CURRENT_PLAYERID && typeof value === 'string') {\n      if (this.isPlaying() && value !== this.player.getId()) {\n        this.pause();\n      }\n    }\n  }\n  /**\r\n   * Diese Methode lädt den übergebenen Stream\r\n   * @param {StreamMedia} mediaStream\r\n   */\n\n\n  loadStream(mediaStream) {\n    var _a;\n\n    var pause = this.model.playstate === 1\n    /* PAUSED */\n    || this.model.playstate === 3\n    /* STOPPED */\n    ; // reset media state\n\n    this.model.playstate = _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__[\"PlayerModel\"].PLAYSTATE_UNSPECIFIED;\n\n    if (!pause) {\n      this.stopOtherPlayingPlayers();\n    } // Notify plugins\n\n\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_LOAD_STREAM, {\n      mediaStream\n    }); // restore possible last position\n\n    this._pendingSeek = this.model.time;\n\n    if (this._pendingSeek === 0 && !this.mc.isLive) {\n      var beginOffset = this.pc.generic.vodInitialPlayheadSeconds;\n\n      if (beginOffset <= 0) {\n        beginOffset = this.pc.generic.vodStartSeconds;\n      }\n\n      this._pendingSeek = beginOffset;\n    } // remove old sources\n\n\n    if (this.mediaElement instanceof HTMLMediaElement) {\n      while (this.mediaElement.children.length > 0) {\n        this.mediaElement.removeChild(this.mediaElement.children[0]);\n      }\n    } // add new sources\n\n\n    this.addSource(mediaStream);\n    /* Lautstärke im Player auf Basis der Konfiguration herstellen. Priorität:\r\n     * 1. forcedVolume\r\n     * 2. Cookie-Value\r\n     * 3. generic.volume\r\n     */\n\n    var fV = (_a = this.pc.web.forcedVolumePercent) !== null && _a !== void 0 ? _a : -1;\n    var v = fV >= 0 ? fV : _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].volume(this.player);\n    var muted = this.pc.generic.isMuted || _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].muted(this.player);\n    this.vc.setVolumeLevel(v, true, muted, true, true); // prevent the player from starting playback from a paused or stopped state when switching streams\n\n    if (pause) {\n      var loadPauser = () => {\n        this.pause();\n        this.mediaElement.removeEventListener('canplay', loadPauser);\n      };\n\n      this.mediaElement.addEventListener('canplay', loadPauser);\n    }\n\n    this.mediaElement.load(); // set defaults for dom element\n\n    this.setPlaybackRate(this.model.playbackRate);\n  }\n  /**\r\n   * Internen Zeit-Ticker starten.\r\n   */\n\n\n  startTicker() {\n    this.stopTicker();\n\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl_updateTickerTimeout, this.player.safeInterval(() => {\n      this.updateTicker();\n    }, 500), \"f\");\n  }\n  /**\r\n   * Internen Zeit-Ticker stoppen.\r\n   */\n\n\n  stopTicker() {\n    clearInterval(__classPrivateFieldGet(this, _AbstractPlayerCtrl_updateTickerTimeout, \"f\"));\n  }\n  /**\r\n   * Zeit-Ticker Updatemethode ausführen.\r\n   */\n\n\n  updateTicker() {\n    this.onTimeChange(this.getDuration(), this.getCurrentTime());\n  }\n  /**\r\n   * Startet die Wiedergabe\r\n   */\n\n\n  play() {\n    var _a; // fixme\n\n\n    if (__classPrivateFieldGet(this, _AbstractPlayerCtrl_errorState, \"f\")) {\n      this.handleError();\n      return;\n    } // respect autoplay policy - https://goo.gl/xX8pDD\n\n\n    (_a = this.mediaElement.play()) === null || _a === void 0 ? void 0 : _a.then(() => {\n      var _a;\n\n      try {\n        this.player.checkState();\n      } catch (e) {\n        _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].warn('aborting async', e);\n        return;\n      } // started, OK\n\n\n      (_a = this.vc) === null || _a === void 0 ? void 0 : _a.hidePosterFrame();\n      this.startTicker();\n    }).catch(e => {\n      var _a, _b, _c;\n\n      _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].error(e);\n\n      try {\n        this.player.checkState();\n      } catch (e) {\n        _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].warn('aborting async', e);\n        return;\n      } // start prohibited, see ARDONI7-6822\n\n\n      (_a = this.player) === null || _a === void 0 ? void 0 : _a.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_AUTOPLAY_STREAM_PROHIBITED, {});\n      (_b = this.vc) === null || _b === void 0 ? void 0 : _b.showPlayBtn();\n      (_c = this.vc) === null || _c === void 0 ? void 0 : _c.showPosterFrame();\n      this.stopTicker();\n    });\n  }\n  /**\r\n   * Pausiert den Clip\r\n   */\n\n\n  pause() {\n    this.mediaElement.pause();\n  }\n  /**\r\n   * Wechselt zwischen Play/Pause (Toggle)\r\n   */\n\n\n  togglePlay() {\n    if (__classPrivateFieldGet(this, _AbstractPlayerCtrl_errorState, \"f\")) {\n      this.handleError();\n      return;\n    }\n\n    if (this.isPlaying()) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n  /**\r\n   * Gibt an, ob der Player zzt. abspielt\r\n   * @return {boolean}\r\n   */\n\n\n  isPlaying() {\n    return this.model.playstate === _model_PlayerModel__WEBPACK_IMPORTED_MODULE_4__[\"PlayerModel\"].PLAYSTATE_PLAYING;\n  }\n  /**\r\n   * Setzt die Lautstärke im Player.\r\n   * @param {number} volume\r\n   * @param {boolean} preventCookie - Änderung nicht im Cookie hinterlegen\r\n   */\n\n\n  setVolume(volume, preventCookie) {\n    if (preventCookie === void 0) {\n      preventCookie = false;\n    }\n\n    if (volume >= 0 && volume <= 100) {\n      if (!preventCookie) {\n        _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].setVolume(this.player, volume);\n      }\n\n      this.mediaElement.volume = volume / 100;\n    }\n  }\n  /**\r\n   * Gibt die Lautstärke zurück (delegiert über Storage)\r\n   * @return {number}\r\n   */\n\n\n  getVolume() {\n    return _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].volume(this.player);\n  }\n  /**\r\n   * Setzt den Mute-Zustand\r\n   * @param {boolean} muted\r\n   * @param {boolean} preventCookie - Änderung nicht im Cookie hinterlegen\r\n   */\n\n\n  setMuted(muted, preventCookie) {\n    if (preventCookie === void 0) {\n      preventCookie = false;\n    }\n\n    this.mediaElement.muted = muted;\n\n    if (this.mediaElement instanceof HTMLMediaElement) {\n      if (muted) {\n        this.mediaElement.setAttribute('muted', 'muted');\n      } else {\n        this.mediaElement.removeAttribute('muted');\n      }\n    }\n\n    if (!preventCookie) {\n      _utils_Storage__WEBPACK_IMPORTED_MODULE_2__[\"Storage\"].setMuted(this.player, muted);\n    }\n  }\n  /**\r\n   * Spult zur angegebenen Zeit innerhalb des Streams.\r\n   * @param {number} seconds - Sprungzeit in Sekunden\r\n   * @param {boolean} preventPlay - Automatische Wiedergabe unterbinden.\r\n   * @param {boolean} preventSeek - Spulvorgang nicht direkt ausführen (erst bei Wiedergabe)\r\n   * @param {boolean} isSubclipSeek - Flag das angibt, ob dieser Sprung automatisch durch den Subclip ausgelöst wurde.\r\n   */\n\n\n  setCurrentTime(seconds, preventPlay, preventSeek, isSubclipSeek) {\n    if (preventPlay === void 0) {\n      preventPlay = false;\n    }\n\n    if (preventSeek === void 0) {\n      preventSeek = false;\n    }\n\n    if (isSubclipSeek === void 0) {\n      isSubclipSeek = false;\n    }\n\n    // reset drift anchoring - we cannot correct for drift across a seeking event\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftBase, 0, \"f\");\n\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftAnchorTime, 0, \"f\");\n\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl__cumulativeDrift, 0, \"f\"); // reset potential subclip seeks\n\n\n    var leftEdge = this.pc.generic.vodStartSeconds;\n    var rightEdge = this.pc.generic.vodEndSeconds;\n\n    if (!isSubclipSeek && (leftEdge > 0 && seconds < leftEdge || rightEdge > 0 && seconds > rightEdge)) {\n      this.resetStartAndEndTime();\n    }\n\n    if (this._ready) {\n      if (!this.canSeek()) {\n        return;\n      } // limit seek to actual possible values.\n\n\n      seconds = Math.max(0, seconds); // By default, set to 0.\n\n      this._pendingSeek = 0;\n\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl_seekPrevPos, this.getCurrentTime(), \"f\");\n\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl_seekToPos, seconds, \"f\");\n\n      try {\n        if (!preventSeek) {\n          // use dvrUtil to calculate correct time in fake dvr mode\n          if (this.dvrUtil !== null) {\n            this.dvrUtil.seek(seconds);\n          } else {\n            this.mediaElement.currentTime = seconds;\n          }\n        } // Dispatch time change event\n        // this.onTimeChange(null, {duration: this.getDuration(), time: seconds, seek: true});\n\n      } catch (Exception) {\n        this._pendingSeek = seconds;\n      }\n    } else {\n      // perform seek as soon as loadedMetadata Event occurs\n      this._pendingSeek = seconds;\n    }\n\n    this.model.time = seconds;\n\n    if (this.isAtEnd && !preventPlay) {\n      this.play();\n    }\n  }\n  /**\r\n   * Spult zum aktuellen Live-Zeitpunkt.\r\n   */\n\n\n  seekToLive() {\n    if (this.canSeek()) {\n      this.setCurrentTime(this.getDuration());\n    }\n  }\n  /**\r\n   * Setzt die Wiedergabegeschwindigkeit\r\n   * @param rate\r\n   */\n\n\n  setPlaybackRate(rate) {\n    this.model.playbackRate = rate;\n    this.mediaElement.playbackRate = rate;\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].PLAYBACK_RATE_CHANGE, {\n      rate: rate\n    });\n  }\n  /**\r\n   * Sofern der aktuelle Player und Stream einen Rückschluss auf die (Echt-)Encoderzeit zulassen,\r\n   * wird ein Object mit den Eigenschaften \"rel\" (relative Zeit im Stream), \"time\" (Echtzeit)\r\n   * und \"at\" (Systemzeit zum Sync-Zeitpunkt) zurückgegeben. Falls nicht unterstützt, wird null\r\n   * zurückgegeben.\r\n   * @returns {object|null}\r\n   */\n\n\n  getDvrToDateSync() {\n    return null;\n  }\n\n  getSmoothDvrToDateSync(pinned) {\n    /*\r\n    we allow pinning to fix time calculation jitter introduced by fluctuations in DvrToDateSync as such:\r\n    first - \"real\":1632902735784,\"at\":1632906938615\r\n    second - \"real\":1632902740009,\"at\":1632906942732\r\n    realDiff: 4225 atDiff: 4117 -> difference in time steps: 108\r\n     */\n    if (pinned) {\n      if (this.pinnedDvrSync == null) {\n        this.pinnedDvrSync = this.getDvrToDateSync();\n      }\n\n      return this.pinnedDvrSync;\n    }\n\n    return this.getDvrToDateSync();\n  }\n  /**\r\n   * Gibt den Unix-Zeitstempel auf Basis des übergebenen (relativen) Zeitstempels im Player zurück\r\n   *\r\n   * In manchen fällen kann während der DVR-Pause das ergebnis von __dvrRelToUnixRaw__ für den gleichen relativen Zeitstempel\r\n   * mit der Zeit einen drift entwickeln. Diese Methode verankert deshalb alle berechnungen von __dvrRelToUnixRaw__\r\n   * an einem fixen paar aus relativem und absolutem Zeitstempel\r\n   * @param {number} relTimestamp Relative Zeit im Player (0 bis Duration)\r\n   * @param {boolean} pinned if true, the first successful call will pin the realtime sync object used for all future calculations where pin is true - fixing jitter at the expense of accuracy\r\n   * @return {number} Unix-Zeitstempel in Sekunden\r\n   */\n\n\n  dvrRelToUnix(relTimestamp, pinned) {\n    if (pinned === void 0) {\n      pinned = false;\n    }\n\n    var dvrToDateSync = this.getSmoothDvrToDateSync(pinned);\n\n    if (dvrToDateSync !== null) {\n      if (pinned) {\n        // skip drift correction, shift result to truncate float\n        return this.__dvrRelToUnixRaw(relTimestamp, dvrToDateSync) << 0;\n      } // init drift correction with previously accumulated drift\n\n\n      var drift = __classPrivateFieldGet(this, _AbstractPlayerCtrl__cumulativeDrift, \"f\");\n\n      if (this.isPlaying()) {\n        // drift tracking during playback is not supported because it's hard and nobody will notice\n        if (__classPrivateFieldGet(this, _AbstractPlayerCtrl__dvrDriftBase, \"f\") !== 0) {\n          // add currently tracked drift to cumulative correction after pause ended\n          __classPrivateFieldSet(this, _AbstractPlayerCtrl__cumulativeDrift, __classPrivateFieldGet(this, _AbstractPlayerCtrl__cumulativeDrift, \"f\") + (this.__dvrRelToUnixRaw(this.getCurrentTime(), dvrToDateSync) - __classPrivateFieldGet(this, _AbstractPlayerCtrl__dvrDriftBase, \"f\")), \"f\"); // reset drift anchoring so it will restart when next paused\n\n\n          __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftBase, 0, \"f\");\n\n          __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftAnchorTime, 0, \"f\");\n        }\n      } else if (__classPrivateFieldGet(this, _AbstractPlayerCtrl__dvrDriftAnchorTime, \"f\") === 0) {\n        // we paused and have no anchor - anchor drift now\n        __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftAnchorTime, this.getCurrentTime(), \"f\");\n\n        __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftBase, this.__dvrRelToUnixRaw(__classPrivateFieldGet(this, _AbstractPlayerCtrl__dvrDriftAnchorTime, \"f\"), dvrToDateSync), \"f\");\n      } else {\n        // we are paused _and_ have a valid anchor\n        // calculate current drift from set anchor, add to cumulative drift from previous pause periods\n        drift += this.__dvrRelToUnixRaw(this.getCurrentTime(), dvrToDateSync) - __classPrivateFieldGet(this, _AbstractPlayerCtrl__dvrDriftBase, \"f\");\n      } // if(drift !== 0) { console.warn(\"DVR DRIFT\", drift, this.#_cumulativeDrift); }\n      // calculate absolute timestamp\n\n\n      var driftyTimestamp = this.__dvrRelToUnixRaw(relTimestamp, dvrToDateSync); // correct for drift, shift to truncate float\n\n\n      return driftyTimestamp - drift << 0;\n    } else if (!pinned) {\n      // reset drift anchoring when no dvr data is available\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftBase, 0, \"f\");\n\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl__dvrDriftAnchorTime, 0, \"f\");\n\n      __classPrivateFieldSet(this, _AbstractPlayerCtrl__cumulativeDrift, 0, \"f\");\n    }\n\n    return 0;\n  }\n  /**\r\n   * Interne berechnung für dvrRelToUnix, führt die eigentliche Berechnung des relativen Zeitstempels\r\n   * ohne korrektur für Zeit-drift aus\r\n   */\n\n\n  __dvrRelToUnixRaw(relTimestamp, dvrToDateSync) {\n    var relPosToCurrentPosOffsetLeft = dvrToDateSync.rel - relTimestamp; // modified to current pos\n\n    var receivedTimeToNowDeltaLeft = Date.now() - dvrToDateSync.at; // offset for delta to last sync\n\n    return (dvrToDateSync.real + // sync timestamp for last received segment\n    receivedTimeToNowDeltaLeft) / 1000 - relPosToCurrentPosOffsetLeft;\n  }\n  /**\r\n   * Gibt eine relative Player-Zeit auf Basis des übergebenen (absoluten) Unix-Zeitstempels\r\n   * zurück.\r\n   * @param {number} unixTimestamp Unix-Zeistempel in Sekunden\r\n   * @return {number} Relative Player-Zeit in Sekunden.\r\n   */\n\n\n  dvrUnixToRel(unixTimestamp) {\n    return unixTimestamp - this.dvrRelToUnix(0);\n  }\n  /**\r\n   * Gibt an, ob der aktuelle Stream ein Seeking unterstützt.\r\n   * @return {boolean}\r\n   */\n\n\n  canSeek() {\n    // this is abstract for the html5 player. hls brings it's own logic so\n    // only need to take pure html5 video into account here.\n    return this.mediaElement instanceof HTMLMediaElement && this.mediaElement.seekable.length > 0;\n  }\n  /**\r\n   * Gibt an, wie viel Prozent der Datei sich bereits im Zwischenspeicher befinden.\r\n   * @return {number}\r\n   */\n\n\n  getPercentBuffered() {\n    return __classPrivateFieldGet(this, _AbstractPlayerCtrl_percentBuffered, \"f\");\n  }\n  /**\r\n   * Returns the current clip time in seconds.\r\n   * @returns {number}\r\n   */\n\n\n  getCurrentTime() {\n    if (this._pendingSeek > 0) {\n      return this._pendingSeek;\n    }\n\n    return this.mediaElement.currentTime;\n  }\n  /**\r\n   * Sets the current clip progress by percent value\r\n   * @param percent\r\n   * @returns {number}\r\n   */\n\n\n  setTimeByPercent(percent) {\n    var targetTime = percent / 100 * this.getDuration();\n    this.setCurrentTime(targetTime);\n    return targetTime;\n  }\n  /**\r\n   * Returns the clip duration in seconds.\r\n   */\n\n\n  getDuration() {\n    var duration = this.mediaElement.duration;\n    return isNaN(duration) ? 0 : duration;\n  }\n  /**\r\n   * Stoppt die Wiedergabe\r\n   */\n\n\n  stop(event) {\n    this.pause();\n    this.jumpToStart();\n    this.stopEventHandler(event);\n  }\n  /**\r\n   * Springt zum Anfang des Stream zurück.\r\n   */\n\n\n  jumpToStart() {\n    this.setCurrentTime(0, true);\n  }\n  /**\r\n   * Diese Methode wird aufgerufen, wenn sich DVR Modus oder DVR Fenster ändern\r\n   * @method onDVRCallback\r\n   **/\n\n\n  onDVRCallback(dvrModeEnabled, dvrWindow, dvrIsLive) {\n    this._dvrEnabled = dvrModeEnabled;\n    this._dvrWindow = dvrWindow;\n    this._dvrIsLive = dvrIsLive;\n    this.player.viewCtrl.onDVRCallback(this._dvrEnabled, this._dvrWindow, this._dvrIsLive);\n    this.player.loop.dispatchEvent(_player_Player__WEBPACK_IMPORTED_MODULE_0__[\"Player\"].EVENT_DVR_CHANGE, {\n      dvrEnabled: this._dvrEnabled,\n      dvrIsLive: this._dvrIsLive,\n      dvrWindow: this._dvrWindow\n    });\n  }\n  /**\r\n   * Gibt eine Liste von AudioTrack Objekten zurück.\r\n   * @return {Array} array of AudioTrack Objects\r\n   */\n\n\n  getAudioTracks() {\n    return [];\n  }\n  /**\r\n   * Setzt das zu verwendende AudioTrack Objekt.\r\n   * @param  {AudioTrack} audioTrack\r\n   */\n\n\n  setAudioTrack(audioTrack) {}\n  /**\r\n   * Setzt das zu verwendende AudioTrack Objekt anhand seiner id.\r\n   * @param  {string} id the audioTrack's id\r\n   */\n\n\n  setAudioTrackById(id) {}\n  /**\r\n   * Gibt das aktuelle AudioTrack Objekt zurück.\r\n   * @return {AudioTrack}\r\n   */\n\n\n  getAudioTrack() {\n    return null;\n  }\n  /**\r\n   * Fehler-Verarbeitung\r\n   */\n\n\n  handleError(error) {\n    var _a;\n\n    this.stopTicker();\n\n    if (error) {\n      _index__WEBPACK_IMPORTED_MODULE_7__[\"console\"].error(error);\n    }\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\n\n\n    __classPrivateFieldSet(this, _AbstractPlayerCtrl_errorState, true, \"f\");\n\n    (_a = this.player.errorCtrl) === null || _a === void 0 ? void 0 : _a.throwStreamError(_ErrorController__WEBPACK_IMPORTED_MODULE_5__[\"ErrorController\"].ERROR_PLAYBACK);\n  }\n\n};\n_AbstractPlayerCtrl_lastSubclipSeektrigger = new WeakMap(), _AbstractPlayerCtrl_lastPlayheadUpdateTime = new WeakMap(), _AbstractPlayerCtrl_buffering = new WeakMap(), _AbstractPlayerCtrl_percentBuffered = new WeakMap(), _AbstractPlayerCtrl__dvrDriftBase = new WeakMap(), _AbstractPlayerCtrl__dvrDriftAnchorTime = new WeakMap(), _AbstractPlayerCtrl__cumulativeDrift = new WeakMap(), _AbstractPlayerCtrl__dropTimeUpdates = new WeakMap(), _AbstractPlayerCtrl_seekPrevPos = new WeakMap(), _AbstractPlayerCtrl_seekToPos = new WeakMap(), _AbstractPlayerCtrl_updateTickerTimeout = new WeakMap(), _AbstractPlayerCtrl_errorState = new WeakMap();\nAbstractPlayerCtrl = __decorate([_utils_Decorators__WEBPACK_IMPORTED_MODULE_8__[\"sealed\"]], AbstractPlayerCtrl);\n\n\n//# sourceURL=webpack://ardplayer/./app/controller/AbstractPlayerCtrl.ts?");

/***/ }),

/***/ "./app/extensions/plugins/MediaElementGenerator.ts":
/*!*********************************************************!*\
  !*** ./app/extensions/plugins/MediaElementGenerator.ts ***!
  \*********************************************************/
/*! exports provided: DefaultMediaElementGenerator, DefaultVideoElementGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultMediaElementGenerator\", function() { return DefaultMediaElementGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultVideoElementGenerator\", function() { return DefaultVideoElementGenerator; });\n/* harmony import */ var _utils_Html5MEFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/Html5MEFactory */ \"./app/utils/Html5MEFactory.ts\");\n/* harmony import */ var _controller_ErrorController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../controller/ErrorController */ \"./app/controller/ErrorController.ts\");\n/* harmony import */ var _utils_Decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/Decorators */ \"./app/utils/Decorators.ts\");\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\nvar DefaultMediaElementGenerator = class DefaultMediaElementGenerator {\n  execute(player, callback) {\n    var _a, _b;\n\n    var mediaCanvas;\n\n    if (player.model.mediaCollection.streams.some(it => !it.isAudioOnly)) {\n      mediaCanvas = _utils_Html5MEFactory__WEBPACK_IMPORTED_MODULE_0__[\"Html5MEFactory\"].createVideo(player);\n    } else {\n      mediaCanvas = _utils_Html5MEFactory__WEBPACK_IMPORTED_MODULE_0__[\"Html5MEFactory\"].createAudio(player);\n    }\n\n    try {\n      (_a = player.viewCtrl) === null || _a === void 0 ? void 0 : _a.removeMediaCanvas();\n    } catch (Exception) {}\n\n    if (mediaCanvas !== null) {\n      callback(mediaCanvas);\n    } else {\n      (_b = player.errorCtrl) === null || _b === void 0 ? void 0 : _b.throwError(_controller_ErrorController__WEBPACK_IMPORTED_MODULE_1__[\"ErrorController\"].MEDIACANVAS_COULD_NOT_GENERATED, true);\n    }\n  }\n\n};\nDefaultMediaElementGenerator = __decorate([_utils_Decorators__WEBPACK_IMPORTED_MODULE_2__[\"sealed\"]], DefaultMediaElementGenerator);\n\nvar DefaultVideoElementGenerator = class DefaultVideoElementGenerator {\n  execute(player, callback) {\n    var _a, _b;\n\n    var mediaCanvas = _utils_Html5MEFactory__WEBPACK_IMPORTED_MODULE_0__[\"Html5MEFactory\"].createVideo(player);\n\n    try {\n      (_a = player.viewCtrl) === null || _a === void 0 ? void 0 : _a.removeMediaCanvas();\n    } catch (Exception) {}\n\n    if (mediaCanvas !== null) {\n      callback(mediaCanvas);\n    } else {\n      (_b = player.errorCtrl) === null || _b === void 0 ? void 0 : _b.throwError(_controller_ErrorController__WEBPACK_IMPORTED_MODULE_1__[\"ErrorController\"].MEDIACANVAS_COULD_NOT_GENERATED, true);\n    }\n  }\n\n};\nDefaultVideoElementGenerator = __decorate([_utils_Decorators__WEBPACK_IMPORTED_MODULE_2__[\"sealed\"]], DefaultVideoElementGenerator);\n\n\n//# sourceURL=webpack://ardplayer/./app/extensions/plugins/MediaElementGenerator.ts?");

/***/ })

}]);