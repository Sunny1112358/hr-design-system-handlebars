(window["webpackJsonpardplayer"] = window["webpackJsonpardplayer"] || []).push([["vendors~pluginhtmla"],{

/***/ "./app/extensions/plugins/html-audio/PluginHTMLAudioLibrary.ts":
/*!*********************************************************************!*\
  !*** ./app/extensions/plugins/html-audio/PluginHTMLAudioLibrary.ts ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _logic_HtmlAudioCtrl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logic/HtmlAudioCtrl */ \"./app/extensions/plugins/html-audio/logic/HtmlAudioCtrl.ts\");\n/* harmony import */ var _MediaElementGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MediaElementGenerator */ \"./app/extensions/plugins/MediaElementGenerator.ts\");\n\n\nvar exports = {\n  Generator: _MediaElementGenerator__WEBPACK_IMPORTED_MODULE_1__[\"DefaultMediaElementGenerator\"],\n  Controller: _logic_HtmlAudioCtrl__WEBPACK_IMPORTED_MODULE_0__[\"HtmlAudioCtrl\"]\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (exports);\n\n//# sourceURL=webpack://ardplayer/./app/extensions/plugins/html-audio/PluginHTMLAudioLibrary.ts?");

/***/ }),

/***/ "./app/extensions/plugins/html-audio/logic/HtmlAudioCtrl.ts":
/*!******************************************************************!*\
  !*** ./app/extensions/plugins/html-audio/logic/HtmlAudioCtrl.ts ***!
  \******************************************************************/
/*! exports provided: HtmlAudioCtrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlAudioCtrl\", function() { return HtmlAudioCtrl; });\n/* harmony import */ var _controller_AbstractPlayerCtrl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../controller/AbstractPlayerCtrl */ \"./app/controller/AbstractPlayerCtrl.ts\");\n/* harmony import */ var _utils_DVRUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/DVRUtil */ \"./app/utils/DVRUtil.ts\");\n/* harmony import */ var _model_PlayerModel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../model/PlayerModel */ \"./app/model/PlayerModel.ts\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../.. */ \"./app/index.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/Utils */ \"./app/utils/Utils.ts\");\n/* harmony import */ var _utils_Decorators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../utils/Decorators */ \"./app/utils/Decorators.ts\");\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _HtmlAudioCtrl_lastTimeupdate, _HtmlAudioCtrl_forcedBuffering;\n\n\n\n\n\n\n\nvar HtmlAudioCtrl = class HtmlAudioCtrl extends _controller_AbstractPlayerCtrl__WEBPACK_IMPORTED_MODULE_0__[\"AbstractPlayerCtrl\"] {\n  constructor(player, htmlPlayer) {\n    super(player, htmlPlayer);\n\n    _HtmlAudioCtrl_lastTimeupdate.set(this, 0);\n\n    _HtmlAudioCtrl_forcedBuffering.set(this, false);\n\n    this.streamResetUrl = 'javascript:void(0)'; // avoid the browser trying to resolve hostname as new sorce\n\n    var isSafari = navigator.userAgent.match(/Safari/i) && !navigator.userAgent.match(/Chrome/i);\n\n    if (isSafari && this.mc.isLive && this.pc.generic.isDvrEnabled) {\n      this.dvrUtil = new _utils_DVRUtil__WEBPACK_IMPORTED_MODULE_1__[\"DVRUtil\"](player, htmlPlayer, this);\n    }\n  }\n\n  addSource(stream) {\n    var _a, _b;\n\n    (_b = (_a = this.player) === null || _a === void 0 ? void 0 : _a.pixelController) === null || _b === void 0 ? void 0 : _b.loadStream(stream.url);\n    var stl = stream.url.toLowerCase(); // for iOS we nee to add the #t= param to the stream to perform our initial seek\n\n    if (___WEBPACK_IMPORTED_MODULE_3__[\"Environment\"].instance.browserIsSafari && this._pendingSeek > 0) {\n      stream.url += \"#t=\" + this._pendingSeek;\n      this._pendingSeek = 0;\n      this.__seeking = true;\n    }\n\n    var createdMappedSource = mimetype => {\n      var source = document.createElement('source');\n      source.src = stream.url;\n      source.type = mimetype;\n      this.mediaElement.appendChild(source);\n      this.emap.map(source, 'error', this.onSourceError, this);\n    };\n\n    switch (true) {\n      case stl.indexOf('.mp3') > 0:\n        createdMappedSource('audio/mpeg');\n        break;\n\n      case stl.indexOf('.ogg') > 0:\n        createdMappedSource('audio/ogg');\n        break;\n\n      case stl.indexOf('.wav') > 0:\n        createdMappedSource('audio/x-wav');\n        break;\n\n      case stl.indexOf('.m3u8') > 0:\n        createdMappedSource('audio/x-mpegurl');\n        break;\n\n      case !Object(_utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"isBlank\"])(stream.mimeType):\n        createdMappedSource(stream.mimeType);\n        break;\n\n      default:\n        this.handleError(\"Unknown mimetype \\\"\" + stream.mimeType + \"\\\" for stream \" + stl);\n        break;\n    }\n\n    if (this.dvrUtil) {\n      this.dvrUtil.initStream(stream.url);\n    }\n  }\n  /**\r\n   * hls special: seek to live playhead for non-dvr enabled liveclips.\r\n   * @inheritDoc\r\n   */\n\n\n  play() {\n    // if the livestream is paused and has no dvr capabilities,\n    // seek to live position as we do not want to play in cache\n    // to prevent buffer holes.\n    if (this.isNonDvrLive() && this.model.playstate === _model_PlayerModel__WEBPACK_IMPORTED_MODULE_2__[\"PlayerModel\"].PLAYSTATE_PAUSED) {\n      this.seekToLive();\n    }\n\n    __classPrivateFieldSet(this, _HtmlAudioCtrl_lastTimeupdate, Date.now(), \"f\");\n\n    __classPrivateFieldSet(this, _HtmlAudioCtrl_forcedBuffering, false, \"f\");\n\n    super.play();\n  }\n\n  isNonDvrLive() {\n    return this.mc.isLive && !this.mediaElement.webkitCurrentPlaybackTargetIsWireless && // not for airplay\n    !this.pc.generic.isDvrEnabled;\n  }\n\n  pause() {\n    if (this.isNonDvrLive()) {\n      var currSource = this.mediaElement.querySelector('source');\n\n      if (currSource) {\n        console.info('stopping non-dvr live stream'); // remove error handler, we will be causing errors shortly\n\n        this.emap.unmap(currSource, 'error', this.onSourceError, this); // store the important info\n\n        currSource.dataset.src = currSource.src;\n        currSource.dataset.type = currSource.type; // replace it with definite locally-resolved error\n\n        currSource.src = this.streamResetUrl;\n        currSource.type = 'void';\n        this.mediaElement.pause(); // after pause is done, reload and _stop stream_ via the error configured above\n\n        this.player.safeTimeout(() => {\n          this.mediaElement.load();\n        }); // skip super impl\n\n        return;\n      }\n    } // no special case -> call super\n\n\n    super.pause();\n  }\n\n  seekToLive() {\n    var _a, _b;\n\n    if (this.isNonDvrLive()) {\n      var currSource = this.mediaElement.querySelector('source');\n\n      if (currSource && currSource.src === this.streamResetUrl) {\n        // check if the reset-url is set just to make doubly sure\n        console.info('seekToLive on non-dvr audio - reload stream');\n        currSource.src = (_a = currSource.dataset.src) !== null && _a !== void 0 ? _a : '';\n        currSource.type = (_b = currSource.dataset.type) !== null && _b !== void 0 ? _b : ''; // make sure the browser does not re-use the previous buffer/cache\n\n        var cleanSrc = currSource.src.replace(/[?&]bufferBuster=\\d+/, '');\n        currSource.src = \"\" + cleanSrc + (cleanSrc.includes('?') ? '&' : '?') + \"bufferBuster=\" + Date.now(); // restore error event handler and start loading\n\n        this.emap.map(currSource, 'error', this.onSourceError, this);\n        this.mediaElement.load(); // skip super implementation\n\n        return;\n      }\n    }\n\n    super.seekToLive();\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  onTimeUpdate() {\n    __classPrivateFieldSet(this, _HtmlAudioCtrl_lastTimeupdate, Date.now(), \"f\");\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  updateTicker() {\n    super.updateTicker(); // no time updates since 2 sec\n\n    if (this.model.playstate === _model_PlayerModel__WEBPACK_IMPORTED_MODULE_2__[\"PlayerModel\"].PLAYSTATE_PLAYING && Date.now() - __classPrivateFieldGet(this, _HtmlAudioCtrl_lastTimeupdate, \"f\") > 2000) {\n      __classPrivateFieldSet(this, _HtmlAudioCtrl_forcedBuffering, true, \"f\"); // force buffering\n\n\n      this.bufferingEventHandler(true);\n    } else {\n      // and reverse it if we are back on time\n      if (__classPrivateFieldGet(this, _HtmlAudioCtrl_forcedBuffering, \"f\")) {\n        // force un-buffer\n        this.bufferingEventHandler(false);\n      }\n    }\n  }\n\n  getClassTypeString() {\n    return 'HtmlAudioCtrl';\n  }\n\n  getDvrToDateSync() {\n    if (this.dvrUtil) {\n      return this.dvrUtil.dvrToDateSync;\n    }\n\n    return null;\n  }\n\n  getCurrentTime() {\n    if (this.dvrUtil) {\n      return this.dvrUtil.getVideoTime();\n    }\n\n    return super.getCurrentTime();\n  }\n\n  getDuration() {\n    if (this.dvrUtil) {\n      return this.dvrUtil.getCurrentDuration();\n    }\n\n    return super.getDuration();\n  }\n\n  setTimeByPercent(percent) {\n    if (this.dvrUtil) {\n      var targetTime = percent / 100 * this.dvrUtil.getCurrentDuration();\n\n      if (percent > 99.9) {\n        this.dvrUtil.seekToLive();\n      } else {\n        this.dvrUtil.seek(targetTime);\n      }\n\n      return targetTime;\n    } else {\n      return super.setTimeByPercent(percent);\n    }\n  }\n\n  setCurrentTime(seconds, preventPlay, preventSeek, isSubclipSeek) {\n    if (preventPlay === void 0) {\n      preventPlay = false;\n    }\n\n    if (preventSeek === void 0) {\n      preventSeek = false;\n    }\n\n    if (isSubclipSeek === void 0) {\n      isSubclipSeek = false;\n    }\n\n    // if seconds are detected as UTC Timestamp, we need to convert them to a relative (seekable) time.\n    if (this.dvrUtil && seconds >= this.dvrRelToUnix(0)) {\n      seconds = this.dvrUnixToRel(seconds); // switch format\n    }\n\n    var performSeekToTime = Math.min(seconds, this.getDuration() - 0.1);\n    return super.setCurrentTime(performSeekToTime, preventPlay, preventSeek, isSubclipSeek);\n  }\n\n  getAudioTrack() {\n    var _a;\n\n    var playing = this.player.currentAudio;\n    return playing ? {\n      id: '0',\n      label: playing.kind,\n      enabled: true,\n      language: (_a = playing === null || playing === void 0 ? void 0 : playing.languageCode) !== null && _a !== void 0 ? _a : 'de'\n    } : null;\n  }\n\n  getAudioTracks() {\n    var curr = this.getAudioTrack();\n    return curr ? [curr] : [];\n  }\n\n  setAudioTrack(audioTrack) {}\n\n  setAudioTrackById(id) {}\n\n  dispose() {\n    super.dispose();\n\n    if (this.dvrUtil) {\n      this.dvrUtil.dispose();\n    }\n  }\n\n};\n_HtmlAudioCtrl_lastTimeupdate = new WeakMap(), _HtmlAudioCtrl_forcedBuffering = new WeakMap();\nHtmlAudioCtrl = __decorate([_utils_Decorators__WEBPACK_IMPORTED_MODULE_5__[\"sealed\"]], HtmlAudioCtrl);\n\n\n//# sourceURL=webpack://ardplayer/./app/extensions/plugins/html-audio/logic/HtmlAudioCtrl.ts?");

/***/ })

}]);